import "highlight.js/styles/github-dark.css";
import hljs from "highlight.js";
import { useEffect } from "react";
import { marked } from "marked";
const personne = `
\`\`\`java
package com.springdata.springdata;

import jakarta.persistence.*;
import org.springframework.data.annotation.Id;

import java.util.List;

@Entity
public class Personne {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nom;
    private String prenoms;
    private String type_permis;
    private int age;

    @OneToMany(mappedBy = "proprietaire", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Voiture> voitures;

    public Personne(Long id, String nom, String prenoms, String type_permis, int age, List<Voiture> voitures) {
        this.id = id;
        this.nom = nom;
        this.prenoms = prenoms;
        this.type_permis = type_permis;
        this.age = age;
        this.voitures = voitures;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public String getPrenoms() {
        return prenoms;
    }

    public void setPrenoms(String prenoms) {
        this.prenoms = prenoms;
    }

    public String getType_permis() {
        return type_permis;
    }

    public void setType_permis(String type_permis) {
        this.type_permis = type_permis;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<Voiture> getVoitures() {
        return voitures;
    }

    public void setVoitures(List<Voiture> voitures) {
        this.voitures = voitures;
    }
}
\`\`\`
`
const voiture = `
\`\`\`java
package com.springdata.springdata;


import jakarta.persistence.*;
import org.springframework.data.annotation.Id;

@Entity
public class Voiture {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String marque;
    private String model;
    private int year;

    @ManyToOne
    @JoinColumn(name = "personne_id")
    private Personne proprietaire;

    public Voiture(Long id, String marque, String model, int year, Personne proprietaire) {
        this.id = id;
        this.marque = marque;
        this.model = model;
        this.year = year;
        this.proprietaire = proprietaire;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getMarque() {
        return marque;
    }

    public void setMarque(String marque) {
        this.marque = marque;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public Personne getProprietaire() {
        return proprietaire;
    }

    public void setProprietaire(Personne proprietaire) {
        this.proprietaire = proprietaire;
    }
}
\`\`\`
`
const voiturerepository = `
\`\`\`java

package com.springdata.springdata;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface VoitureRepository extends CrudRepository<Voiture, Long> {
    @Query("SELECT v FROM Voiture v WHERE v.proprietaire.nom = :nom")
    List<Voiture> findVoituresByProprietaireNom(@Param("nom") String nom);

    @Query("SELECT v FROM Voiture v JOIN v.proprietaire p WHERE p.age > :age")
    List<Voiture> findVoituresByProprietaireAgeGreaterThan(@Param("age") int age);

    @Query("SELECT v FROM Voiture p WHERE v.year > :year")
    List<Personne> findByAgeGreaterThan(@Param("year") int year);

}
\`\`\`
`
const personnerepository = `
\`\`\`java

package com.springdata.springdata;

import org.springframework.boot.autoconfigure.data.web.SpringDataWebProperties;
import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface PersonneRepository extends CrudRepository<Personne, Long> {

    List<Personne> findByNomPrenonne(String nom, String prenoms);
    List<Personne> findByNomAndAge(String nom, int age);
    List<Personne> findByAgeGreaterThan(int age);
    List<Personne> findByNomOrderByAgeDesc(String nom);
    List<Personne> findByNom(String nom, SpringDataWebProperties.Sort sort);

}
\`\`\`
`
const personneservice = `
\`\`\`java
package com.springdata.springdata;

import org.springframework.beans.factory.annotation.Autowired;
import  org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.List;

@Service
public class PersonneService {

    private final PersonneRepository personneRepository;
    @Autowired
    public PersonneService(PersonneRepository personneRepository) {
        this.personneRepository = personneRepository;
    }

    public List<Personne> findByNomOrPrenoms(String nom, String prenoms) {
        return personneRepository.findByNomOrPrenoms(nom, prenoms);
    }

    public List<Personne> findByNomAndAge(String nom, int age) {
        return personneRepository.findByNomAndAge(nom, age);
    }

    public List<Personne> findByAgeGreaterThan(int age) {
        return personneRepository.findByAgeGreaterThan(age);
    }

    public List<Personne> findByNomOrderByAgeDesc(String nom) {
        return personneRepository.findByNomOrderByAgeDesc(nom);
    }

    public List<Personne> findByNom(String nom, Sort sort) {
        return personneRepository.findByNom(nom, sort);
    }
    public Personne savePersonne(@RequestBody Personne personne) {

        return personneRepository.save(personne);
    }
}
\`\`\`
`
const voitureservice = `
\`\`\`java
package com.springdata.springdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class VoitureService {

    private final VoitureRepository voitureRepository;
    @Autowired
    public VoitureService(VoitureRepository voitureRepository) {
        this.voitureRepository = voitureRepository;
    }

    public List<Voiture> findVoituresByProprietaireNom(String nom) {
        return voitureRepository.findVoituresByProprietaireNom(nom);
    }

    public List<Voiture> findVoituresByProprietaireAgeGreaterThan(int age) {
        return voitureRepository.findVoituresByProprietaireAgeGreaterThan(age);
    }

    public List<Voiture> findByYearGreaterThan(int year) {
        return voitureRepository.findByAgeGreaterThan(year);
    }
    public Voiture saveVoiture(Voiture voiture) {
        return voitureRepository.save(voiture);
    }
}
\`\`\`
`

const voiturecontroller = `
\`\`\`java
package com.springdata.springdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/voitures")
public class VoitureController {

    private final VoitureService voitureService;

    @Autowired
    public VoitureController(VoitureService voitureService) {
        this.voitureService = voitureService;
    }

    @GetMapping("/proprietaireNom")
    public List<Voiture> getVoituresByProprietaireNom(@RequestParam String nom) {
        return voitureService.findVoituresByProprietaireNom(nom);
    }

    @GetMapping("/proprietaireAgeGreaterThan")
    public List<Voiture> getVoituresByProprietaireAgeGreaterThan(@RequestParam int age) {
        return voitureService.findVoituresByProprietaireAgeGreaterThan(age);
    }

    @GetMapping("/yearGreaterThan")
    public List<Voiture> getVoituresByYearGreaterThan(@RequestParam int year) {
        return voitureService.findByYearGreaterThan(year);
    }

    // MÃ©thode pour ajouter une nouvelle voiture
    @PostMapping
    public Voiture saveVoiture(@RequestBody Voiture voiture) {
        return voitureService.saveVoiture(voiture);
    }
}
\`\`\`
`
const personnecontroller = `
\`\`\`java
package com.springdata.springdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("api/personnes")
public class PersonneController {

    private final PersonneService  personneService;

    @Autowired
    public PersonneController(PersonneService personneService) {
        this.personneService = personneService;
    }
    @PostMapping()
    public Personne save(@RequestBody Personne personne) {
        return personneService.savePersonne(personne);
    }

    @GetMapping("/nomPrenoms")
    public List<Personne> getPersonnesByNomPrenoms(@RequestParam String nom, @RequestParam String prenoms) {
        return personneService.findByNomOrPrenoms(nom, prenoms);
    }

    @GetMapping("/nomAndAge")
    public List<Personne> getPersonnesByNomAndAge(@RequestParam String nom, @RequestParam int age) {
        return personneService.findByNomAndAge(nom, age);
    }

    @GetMapping("/ageGreaterThan")
    public List<Personne> getPersonnesByAgeGreaterThan(@RequestParam int age) {
        return personneService.findByAgeGreaterThan(age);
    }

    @GetMapping("/nomOrderByAgeDesc")
    public List<Personne> getPersonnesByNomOrderByAgeDesc(@RequestParam String nom) {
        return personneService.findByNomOrderByAgeDesc(nom);
    }

    @GetMapping("/nomSorted")
    public List<Personne> getPersonnesByNomSorted(@RequestParam String nom, @RequestParam String sortField, @RequestParam String sortDirection) {
        Sort sort = Sort.by(Sort.Direction.fromString(sortDirection), sortField);
        return personneService.findByNom(nom, sort);
    }
}
\`\`\`
`
export default function SpringDataJpa() {
    useEffect(() => {
        hljs.highlightAll();
      }, []);
  
    return(
        <>
        <div className="postMeta">
            <div className="postDate">Publier le 31 Juillet 2024</div>
            <h1>Fondements de Spring data jpa</h1>
            <div className="postImage">
                    <img src="/default.jpg" alt=""/>
                </div>
        </div>
       
        <div className="postContent">
                <div>
                <h5 className="postinfo">Qu'est ce que vous allez apprendre?</h5>
                <p>
                    Vous allez apprendre dans cette article comment gÃ©rer les donnÃ©es sous spring data jpa
                </p>
                <h5 className="postinfo">Qu'est ce que vous devez disposer?</h5>
                <ul>
                    <li>Une base en programmation java et en Spring boot</li>
                    <li>Un IDE : Eclipse, InteliJ, VsCode ou autre</li>
                    <li>Postman</li>
                </ul>
                <h5 className="postinfo">Pratiquez</h5>
                <p>
                    La meilleurs maniÃ¨re de tirer profit de ce projet est de pratiquer au fuir et 
                    Ã¡ mesure que vous lisez, pour allez plus vite, j'ai mis Ã¡ votre disposition
                    le code source de ce projet sur mon compte <a href="https://github.com/Badjodibe/springdata">en cliquant ici</a>.
                </p>
                <h3>Introduction</h3>
                <p>
                    Spring data est un Ã©cosystÃ¨mes facilitant l'accÃ¨s, l'interaction avec les base 
                    de donnÃ©es sur le framework spring boot. Il permet d'accÃ©dÃ© Ã¡ de base de donnÃ©es 
                    de type diffÃ©rent que Ã§a soit relationnelle ou non relationnelle.
                    Le projet spring data  regroupe plusieurs sous projet incluant spring data jpa, 
                    qui est une extension et amÃ©lioration de JPA (Java persistance API), 
                    il est conÃ§u pour facilitÃ© l'interaction avec les bases de donnÃ©es relationnelle.
                    Dans cette article, nous allons parcourir les fondements de spring data jpa,
                    les conceptes, comment crÃ©er et interagir avec une base de donnÃ©es relationnelle.
                    Nous terminerons par faire projet en dÃ©veloppant une application web.
                </p>
                <h5>Spring Data JPA</h5>
                <div>
                    <h5>Entity</h5>
                    <p>
                        Objet relationnal mapping (ORM) est une approche dans le dÃ©veloppement de 
                        logiciel consistant Ã¡ faire correspondre des objets Ã¡ des tables d'une base 
                        de donnÃ©es afin de facilitÃ© la crÃ©ation et la manipulation des observations 
                        dans la base de donnÃ©es. Dans cette approche, les entitÃ©s reprÃ©sentent une 
                        table de la base de donnÃ©es, comme les tables ces entitÃ©es peuvent avoir des 
                        relations avec d'autre entitÃ©es. ConcrÃ¨tement, une entitÃ© est un classe java 
                        annotÃ© par une annotation Entity, ce qui permet Ã¡ spring boot de le considÃ©rÃ©
                        comme une table d'une base de donnÃ©es et de gÃ©rÃ© automatiquement sont cycle
                        de vie. Les champs dans cette classe font rÃ©fÃ©rence aux champs de la table 
                        correspondante dans la base de donnÃ©es.
                        L'interaction avec les observations ou leur crÃ©ation se fait Ã¡ l'aide
                        repository (un entrepot)  
                    </p>
                    <h5>Repository</h5>
                    <p>
                        Les tables de la base de donnÃ©es Ã©tant gÃ©rÃ© par les entitÃ©es, comment 
                        interagir avec les tables de la base de donnÃ©es, le concept de Repository 
                        permet d'arrivÃ© Ã¡ cette fin. Ces derniers sont utilisÃ© pour interagir avec 
                        la base de donnÃ©es en effectuant toutes les opÃ©rations classique sur les 
                        bases de donnÃ©es. Au lieu d'Ã©crir les requÃªtes sql en utilisant la l'api jdbc
                        de java, les rÃ©positories reprÃ©sentes ces reequÃªte sous forme de fonction 
                        simplifier, en adoptant un nommage qui gÃ©nÃ¨re automatiquement les rÃ©quÃªtes.
                        Quand un rÃ©pository est crÃ©er, les fonctions crud de base sont sont gÃ©nÃ©rÃ©es 
                        automatiquement. Sans le rÃ©crÃ©er ils peuvent se faire appÃ¨le directement.
                        Les repositories sont des interfaces qui Ã©tendent la classe JPARepository ou
                        CrudRepository. Le dernier est une amÃ©lioration du premier. spring data 
                        jpa est trÃ¨s flexible il adoptique une maniÃ¨re simple et puissant pour Ã©crire
                        requÃªte personnalisÃ©. Avant de voir les diffÃ©rentes maniÃ¨re d'Ã©crire les 
                        requÃªtes personnalisÃ©, voyons d'abord les methodes de bases qui sont mis Ã¡ 
                        notre disposition.
                    </p>
                    <ul>
                        <li>
                            <h6>RequÃªtes de base</h6>
                            <p>
                                Lorsque vous crÃ©er un repository, un ensemble de methode sont 
                                prÃ©dÃ©finie, ils reprÃ©santent  les opÃ©ration  Crud 
                                (CrÃ©er, rechercher, supprimer, modifier) de base. Par exemple la 
                                fonctions save correspond Ã¡ la requÃªte demandant de stocker une 
                                observation dans la base de donnÃ©es. Spring boot est trÃ¨s puissant,
                                il donne la possibilitÃ© d'Ã©crire les requÃªtes personnalisÃ©es soit en
                                utilisant les requÃªtes de methodes dÃ©rivÃ©es ou en Ã©crivant les 
                                requÃªtes personnalisÃ©es Ã¡ l'aide du langage JPQL 
                                (Java Persistance query langage)  
                            </p>
                        </li>
                        <li>
                            <h6>RequÃªtes dÃ©rivÃ©es de mÃ©thodes</h6>
                            <p>
                                Les methodes dÃ©rivÃ©es sont des mÃ©thode permettant d'exprimer les 
                                requÃªtes personnalisÃ©es. Ils simplifient considÃ©rablement l'Ã©criture
                                des requÃªtes plus ou moins complÃ¨te. Vous pouvez Ã©crir des requÃªtes 
                                en faisant intervenir les conditions, les mots clÃ© comme like, 
                                lessthan etc.
                            </p>
                            <h6>Principe</h6>
                            <ul>
                                <li>
                                    Commencer par le mots expriment l'action : L'action que vous 
                                    voudriez effectuÃ© est dÃ©finie par un mot clÃ©.
                                    Le nom de la fonction commence par le mot clÃ© correspondant.
                                    Ceci peux Ãªtre find, count, get etc
                                </li>
                                <li>
                                    Le nom du champs : Suivant ce mot clÃ©s le nom du champs sur 
                                    lequel porte la rÃ©quÃªte. Par convention le nom du champs est 
                                    capitalisÃ©.
                                </li>
                                <li>
                                    Connecteur logique : Il est possible d'utilisÃ© les connecteurs 
                                    logiques. Il y a deux le Or et le And.
                                </li>
                                <li>
                                    Mots clÃ©s de condition : Vous avez la possibilitÃ© d'utilisÃ© les 
                                    mots clÃ©s comme GreaterThan, LessThan ou bien Between.
                                </li>
                            </ul>
                        </li>
                        <li>
                            <h6>RequÃªtes JPQL (Java Persistence Query Language)</h6>
                            <p>
                            JPQL est une autre maniÃ¨re puissant d'Ã©crire les requÃªte personnalisÃ©.
                            C'est un langage de requÃªte pour effectuer des requÃªtes sur des objets 
                            entitÃ©s gÃ©rÃ©s par JPA (Java Persistence API). Il ressemble Ã  PLSQL, 
                            mais opÃ¨re sur les objets entitÃ©s et leurs propriÃ©tÃ©s au lieu des tables
                            et des colonnes de la base de donnÃ©es.
                            Vous pouvez dÃ©finir des requÃªtes JPQL dans votre interface repository en utilisant l'annotation @Query.
                            </p>
                        </li>
                    </ul>
                </div>
                <h5>Les differentes relation entre les tables</h5>
                <p>
                    Les entitÃ©es sont des classes qui reprÃ©sentes les tables de la base, donc 
                    logiquement, il est possible de lier deux entitÃ©es par une relation.
                    Plusieurs relation existent, les relations courament utilisÃ© sont :
                    un Ã¡ un (une observation d'une table ne peux qu'Ãªtre liÃ©e au maximuim qu'a une
                    observation d'une autre table, exprimant l'injectivitÃ©), un Ã¡ plusieurs 
                    (une observation d'une tables peux avoir plusieurs correspondant dans une autre 
                    tables exprimant la surjectivitÃ©) et plusieurs Ã¡ plusieurs.
                </p>
                <h5>Comment crÃ©er les relations?</h5>
                <p>
                    <ul>
                        <li>
                            <h6>Relation un Ã¡ un</h6>
                            <p>
                                L'annotation @OneToOne permet de crÃ©er une relation un Ã¡ un
                            </p>
                            
                        </li>
                        <li>
                            <h6>Relation un Ã¡ plusieurs</h6>
                            <p>
                                Cette relation est rÃ©alisÃ© Ã¡ l'aide de l'annotation @OnToMany,
                                supposons deux classe une personne et une voitures. La relation qui 
                                lie ces deux classes est la relation un Ã¡ plusieurs. Une peresonne 
                                peux avoir plusieurs voiture, inversement plusieurs voiture peuvent 
                                appartenir Ã¡ une personne. Pour relalisÃ© cette relation, l'annotation
                                OneToMany est crÃ©er dans la classe personne et ManyToOne dans la 
                                classe voiture
                            </p>
                        </li>
                        <li>
                            <h6>Relation plusieurs Ã¡ plusieurs</h6>
                            <p>
                                Une exemple pour cette relation est le suivant, dans les rÃ©seaux 
                                sociaux, plusieurs utilisateurs peuvent appartenir Ã¡ un seul groupe 
                                et une une personne peux intÃ©grÃ©e plusieurs groupe, ce type de 
                                realtion est une relation plusieurs Ã¡ plusieurs.
                                Pour le rÃ©alisÃ©, vous devez utilisÃ© l'annotation ManyToMany dans les 
                                deux classe.
                            </p>
                        </li>
                    </ul>
                </p>
        
                <h5>Application</h5>
                <p>
                    Nous allons crÃ©er une application qui va gÃ©rer un ensemble de voiture et ses 
                    propriÃ©taire, elle comprendra deux modÃ¨le, une pour les voitures et l'autre pour
                    les propriÃ©taire. Dans notre modÃ¨les, une personnes peux disposer plusieurs
                    voitures, mais une voiture ne peux avoir qu'un seul propriÃ©taire ce qui veux 
                    dire que la tables qui represente les voitres et les propriÃ©taires on une 
                    relation un Ã¡ plusieurs. Ensuite nous allons crÃ©er un ensemble de requÃªtes pour 
                    rÃ©cupÃ©rer les donnÃ©es dans la base de donnÃ©es.
                </p>
                <p>
                    Si vous n'avez pas encore l'initializer de spring boot qui permet d'initialisÃ© 
                    les applications spring boot, vous pouvez le tÃ©lÃ©chargÃ© sur ce lien
                    [lien de spring boot initializer].

                </p>
                <h5>Ajout de dÃ©pendances</h5>
                <p>

                </p>
                <h5>Creation de l'entitÃ© personne</h5>
                <p>
                    Une personne est identifier par quelques champs, ou information.
                    En plus de ces champs, un autre champs reprÃ©sentant l'ensemble des voitures 
                    appartenant Ã¡ cette personne, c'est la relation un Ã¡ plusieurs.
                    Il y a aussi une champs qui est nommÃ© id, ceci reprÃ©sente l'identifiant de 
                    cette table dans la base de donnÃ©es, ce champs est annotÃ© par l'annotation Id 
                    et la stratÃ©gie utilisÃ© pour gÃ©nÃ©rer les valeures de ce champs.
                </p>
                <div dangerouslySetInnerHTML={{ __html: marked(personne) }}></div>
                <h5>EntitÃ© voiture</h5>
                <p>
                    De la mÃªme maniÃ¨re qu'une personne, une voiture Ã¡ ces information qui sont 
                    la marque, le model et l'annÃ©e de fabrication. Cette classe dispose d'une 
                    relation de plusieurs Ã¡ un avec la classe personne, c'est Ã¡ dire une 
                    personne peux avoir plusieurs voiture
                </p>
                <div dangerouslySetInnerHTML={{ __html: marked(voiture) }}></div>
                <p>
                    Une entitÃ© reprÃ©sente une table dans la base de donnÃ©es. Spring boot gÃ¨re 
                    la crÃ©ation automatique de la table correspondance Ã¡ l'entitÃ© dans la base de 
                    donnÃ©es. L'interaction avec avec la base de donnÃ©es se fait avec les rÃ©pository.
                    Nous allons crÃ©er des repositories correspondant Ã¡ chaque entitÃ©.
                </p>
                <h5>VoitureRepository</h5>
                <p>
                    Cette interface implementant CrudRepository reprÃ©sente l'objet qui va interagir 
                    avec la base de donnÃ©es, Ã©ffectuÃ© les opÃ©rations afin de retirÃ© les donnÃ©es 
                    de la bases de donnÃ©es. Dans cette classe il y a plusieurs fonctions et chaque 
                    fonction reprÃ©sente une requÃªte.  Par exemple le premier correspond au voiture
                    d'une personne identifiÃ© par son nom
                </p>
                <div dangerouslySetInnerHTML={{ __html: marked(voiturerepository) }}></div>
                <h5>PersonneRepository</h5>
                <p>
                    De la mÃªme maniÃ¨re que VoitureRepository, nous allons crÃ©er PersonneRepository
                    pour va retirer les observations des personnes enrÃ©gistrÃ© dans la base de donnÃ©es.
                    Cette fois si nous allons utilisÃ© la technique de methodes personnalisÃ© pour 
                    Ã©crire les requÃªtes. 
                </p>
                <div dangerouslySetInnerHTML={{ __html: marked(personnerepository) }}></div>
                <p>
                    L'application est une application web, nous allons dÃ©velopper les services 
                    et les contrÃ´leur pour tester la connection et l'excÃ©cution des opÃ©rations 
                    sur la base de donnÃ©es. CommenÃ§ons par crÃ©er les services.
                    Pour chacune de ces services.
                </p>
                <h5>Service des personnes</h5>
                <div dangerouslySetInnerHTML={{ __html: marked(personneservice) }}></div>
                <h5>Service des voitures</h5>
                <div dangerouslySetInnerHTML={{ __html: marked(voitureservice) }}></div>
                <p>Maintenant dÃ©veloppons les controllers, le points d'accÃ¨s Ã¡ notre application</p>
                <h5>Controller des voitures</h5>
                <div dangerouslySetInnerHTML={{ __html: marked(voiturecontroller) }}></div>
                <h5>Controller des personnes</h5>
                <div dangerouslySetInnerHTML={{ __html: marked(personnecontroller) }}></div>
                <p>
                    Pour vÃ©rifier le bon fonctionnement de l'application, lancer cette derniÃ¨re et 
                    aller sous le port de l'exÃ©cution de l'application sur postman et envoyÃ© des 
                    requÃªtes.
                </p>
                <h3>Conclusion</h3>
                <p>
                    Dans ce projet nous avons vu les bases de l'Ã©cosystÃ¨me de spring data jpa.
                    Deux concept sont trÃ¨s important, les entitÃ©es qui sont des classes qui 
                    reprÃ©sentent les tables de la base de donnÃ©es. Ces entitÃ¨es supportent tous
                    les types de relation Ã©quivalent au type de relation qui existe dans les base
                    de donnÃ©es relationnelle. Pour interagir avec la base de donnÃ©es,
                    les repositories sont utilisÃ©s, ces derniers sont des interfaces utilisÃ©es
                    pour interagir avec les base de donnÃ©es. Dans les repositories il y a des 
                    fonctions de bases, qui sont gÃ©nÃ©rÃ© automatiquement correspondant aux fonction 
                    crud, mais aussi il y a des maniÃ¨res simple, flexible d'Ã©crire notre fonction 
                    personnalisÃ©. Spring data jpa est composÃ© d'un ensemble d'annotation, d'ailleurs 
                    spring boot est basÃ© sur les annotations qui force les classe Ã¡ adoptÃ© certains
                    comportement. 
                </p>
            </div>
        </div>
    </>
        )
}